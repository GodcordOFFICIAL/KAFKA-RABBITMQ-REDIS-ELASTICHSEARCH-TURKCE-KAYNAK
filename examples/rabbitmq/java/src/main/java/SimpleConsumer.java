package com.example.rabbitmq;

import com.rabbitmq.client.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * RabbitMQ Simple Consumer
 * 
 * Bu sƒ±nƒ±f farklƒ± consumer pattern'lerini g√∂sterir:
 * - Basit queue consumer
 * - Work queue consumer (ack/nack handling)
 * - Fanout exchange consumer
 * - Priority queue consumer
 * - Manual acknowledgment handling
 */
public class SimpleConsumer {

    private static final Logger logger = LoggerFactory.getLogger(SimpleConsumer.class);

    // RabbitMQ connection parameters
    private static final String HOST = "localhost";
    private static final int PORT = 5672;
    private static final String USERNAME = "admin";
    private static final String PASSWORD = "admin123";

    // Queue and Exchange names
    private static final String SIMPLE_QUEUE = "hello";
    private static final String TASK_QUEUE = "task_queue";
    private static final String LOGS_EXCHANGE = "logs";

    private Connection connection;
    private Channel channel;
    private ObjectMapper objectMapper;
    private String consumerTag;

    public SimpleConsumer() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
    }

    /**
     * RabbitMQ baƒülantƒ±sƒ± olu≈ütur
     */
    public void connect() throws IOException, TimeoutException {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST);
        factory.setPort(PORT);
        factory.setUsername(USERNAME);
        factory.setPassword(PASSWORD);

        // Connection recovery ayarlarƒ±
        factory.setAutomaticRecoveryEnabled(true);
        factory.setNetworkRecoveryInterval(10000);

        // Consumer i√ßin prefetch ayarƒ±
        try {
            connection = factory.newConnection();
            channel = connection.createChannel();

            // Fair dispatch - worker'lar arasƒ± load balancing i√ßin
            channel.basicQos(1);

            logger.info("‚úÖ RabbitMQ'ya baƒülandƒ±");
        } catch (IOException | TimeoutException e) {
            logger.error("‚ùå RabbitMQ baƒülantƒ± hatasƒ±", e);
            throw e;
        }
    }

    /**
     * Basit mesaj t√ºketme - Auto acknowledgment
     * 
     * Avantajlarƒ±:
     * - Simple implementation
     * - Automatic message acknowledgment
     * 
     * Dezavantajlarƒ±:
     * - Risk of message loss on failure
     * - No control over acknowledgment timing
     */
    public void consumeSimpleMessages() throws IOException {
        // Queue declare et
        channel.queueDeclare(SIMPLE_QUEUE, true, false, false, null);

        logger.info("üîÑ Basit mesajlar dinleniyor... √áƒ±kmak i√ßin CTRL+C");

        // Auto-ack consumer
        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            try {
                String message = new String(delivery.getBody(), "UTF-8");

                // JSON parse et
                @SuppressWarnings("unchecked")
                Map<String, Object> messageData = objectMapper.readValue(message, Map.class);

                // Mesajƒ± i≈üle
                processSimpleMessage(messageData, delivery.getProperties());

                logger.info("‚úÖ Basit mesaj i≈ülendi: {}", messageData.get("message"));

            } catch (Exception e) {
                logger.error("‚ùå Mesaj i≈üleme hatasƒ±", e);
            }
        };

        CancelCallback cancelCallback = consumerTag -> {
            logger.info("‚ö†Ô∏è Consumer iptal edildi: {}", consumerTag);
        };

        // Consumer'ƒ± ba≈ülat (auto-ack enabled)
        this.consumerTag = channel.basicConsume(SIMPLE_QUEUE, true, deliverCallback, cancelCallback);
    }

    /**
     * Work queue consumer - Manual acknowledgment
     * 
     * Avantajlarƒ±:
     * - Full control over message acknowledgment
     * - No message loss on processing failure
     * - Retry mechanism support
     * 
     * Dezavantajlarƒ±:
     * - More complex implementation
     * - Manual error handling required
     */
    public void consumeWorkQueue() throws IOException {
        // Durable queue declare et
        Map<String, Object> args = new java.util.HashMap<>();
        args.put("x-max-priority", 10); // Priority queue

        channel.queueDeclare(TASK_QUEUE, true, false, false, args);

        logger.info("üîß Work queue dinleniyor... √áƒ±kmak i√ßin CTRL+C");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            try {
                String message = new String(delivery.getBody(), "UTF-8");

                // JSON parse et
                @SuppressWarnings("unchecked")
                Map<String, Object> taskData = objectMapper.readValue(message, Map.class);

                // Task'ƒ± i≈üle
                boolean success = processTask(taskData, delivery.getProperties());

                if (success) {
                    // Ba≈üarƒ±lƒ± i≈ülem - acknowledge
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                    logger.info("‚úÖ Task tamamlandƒ±: {}", taskData.get("task"));
                } else {
                    // ƒ∞≈ülem ba≈üarƒ±sƒ±z - reject ve requeue
                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);
                    logger.warn("‚ö†Ô∏è Task ba≈üarƒ±sƒ±z, yeniden kuyruƒüa alƒ±ndƒ±: {}", taskData.get("task"));
                }

            } catch (Exception e) {
                logger.error("‚ùå Task i≈üleme hatasƒ±", e);
                try {
                    // Exception durumunda message'ƒ± reject et
                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);
                } catch (IOException ioException) {
                    logger.error("‚ùå Message reject hatasƒ±", ioException);
                }
            }
        };

        CancelCallback cancelCallback = consumerTag -> {
            logger.info("‚ö†Ô∏è Worker consumer iptal edildi: {}", consumerTag);
        };

        // Consumer'ƒ± ba≈ülat (manual ack)
        this.consumerTag = channel.basicConsume(TASK_QUEUE, false, deliverCallback, cancelCallback);
    }

    /**
     * Fanout exchange consumer - Log mesajlarƒ±
     * 
     * Her consumer kendi queue'suna bind olur ve t√ºm log mesajlarƒ±nƒ± alƒ±r
     */
    public void consumeLogMessages(String consumerName) throws IOException {
        // Fanout exchange declare et
        channel.exchangeDeclare(LOGS_EXCHANGE, BuiltinExchangeType.FANOUT, true);

        // Ge√ßici queue olu≈ütur (exclusive ve auto-delete)
        String queueName = channel.queueDeclare("", false, true, true, null).getQueue();

        // Queue'yu exchange'e bind et
        channel.queueBind(queueName, LOGS_EXCHANGE, "");

        logger.info("üìù [{}] Log mesajlarƒ± dinleniyor... √áƒ±kmak i√ßin CTRL+C", consumerName);

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            try {
                String message = new String(delivery.getBody(), "UTF-8");

                // JSON parse et
                @SuppressWarnings("unchecked")
                Map<String, Object> logData = objectMapper.readValue(message, Map.class);

                // Log mesajƒ±nƒ± i≈üle
                processLogMessage(consumerName, logData, delivery.getProperties());

            } catch (Exception e) {
                logger.error("‚ùå Log mesajƒ± i≈üleme hatasƒ±", e);
            }
        };

        CancelCallback cancelCallback = consumerTag -> {
            logger.info("‚ö†Ô∏è Log consumer [{}] iptal edildi: {}", consumerName, consumerTag);
        };

        // Consumer'ƒ± ba≈ülat (auto-ack for logs)
        this.consumerTag = channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    }

    /**
     * Priority aware consumer - √ñncelik sƒ±rasƒ±na g√∂re task i≈üleme
     */
    public void consumeWithPriority() throws IOException {
        Map<String, Object> args = new java.util.HashMap<>();
        args.put("x-max-priority", 10);

        channel.queueDeclare(TASK_QUEUE, true, false, false, args);

        logger.info("‚≠ê Priority queue dinleniyor... √áƒ±kmak i√ßin CTRL+C");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            try {
                String message = new String(delivery.getBody(), "UTF-8");

                @SuppressWarnings("unchecked")
                Map<String, Object> taskData = objectMapper.readValue(message, Map.class);

                // Priority bilgisini al
                Integer priority = delivery.getProperties().getPriority();
                if (priority == null)
                    priority = 0;

                logger.info("‚≠ê Priority {} task alƒ±ndƒ±: {}", priority, taskData.get("task"));

                // Priority'ye g√∂re i≈ülem s√ºresi sim√ºle et
                simulateTaskProcessing(priority);

                // Task'ƒ± i≈üle
                boolean success = processTask(taskData, delivery.getProperties());

                if (success) {
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                    logger.info("‚úÖ Priority {} task tamamlandƒ±", priority);
                } else {
                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);
                    logger.warn("‚ö†Ô∏è Priority {} task ba≈üarƒ±sƒ±z", priority);
                }

            } catch (Exception e) {
                logger.error("‚ùå Priority task i≈üleme hatasƒ±", e);
                try {
                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);
                } catch (IOException ioException) {
                    logger.error("‚ùå Priority task reject hatasƒ±", ioException);
                }
            }
        };

        CancelCallback cancelCallback = consumerTag -> {
            logger.info("‚ö†Ô∏è Priority consumer iptal edildi: {}", consumerTag);
        };

        this.consumerTag = channel.basicConsume(TASK_QUEUE, false, deliverCallback, cancelCallback);
    }

    /**
     * Basit mesaj i≈üleme business logic'i
     */
    private void processSimpleMessage(Map<String, Object> messageData, AMQP.BasicProperties properties) {
        String message = (String) messageData.get("message");
        String timestamp = (String) messageData.get("timestamp");
        String sender = (String) messageData.get("sender");

        logger.info("üì® Mesaj: '{}' (G√∂nderen: {}, Zaman: {})", message, sender, timestamp);

        // Business logic sim√ºlasyonu
        try {
            Thread.sleep(500); // 500ms i≈ülem s√ºresi
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Task i≈üleme business logic'i
     */
    private boolean processTask(Map<String, Object> taskData, AMQP.BasicProperties properties) {
        String task = (String) taskData.get("task");
        Integer priority = (Integer) taskData.get("priority");
        String timestamp = (String) taskData.get("timestamp");

        logger.info("üîß Task i≈üleniyor: '{}' (Priority: {}, Zaman: {})", task, priority, timestamp);

        try {
            // Task s√ºresini priority'ye g√∂re belirle
            int processingTime = calculateProcessingTime(task, priority);
            Thread.sleep(processingTime);

            // %90 ba≈üarƒ± oranƒ± sim√ºlasyonu
            boolean success = Math.random() > 0.1;

            if (success) {
                logger.info("‚úÖ Task ba≈üarƒ±yla tamamlandƒ±: {}", task);
            } else {
                logger.warn("‚ùå Task ba≈üarƒ±sƒ±z: {}", task);
            }

            return success;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }

    /**
     * Log mesajƒ± i≈üleme
     */
    private void processLogMessage(String consumerName, Map<String, Object> logData, AMQP.BasicProperties properties) {
        String level = (String) logData.get("level");
        String message = (String) logData.get("message");
        String timestamp = (String) logData.get("timestamp");
        String source = (String) logData.get("source");

        // Log level'a g√∂re farklƒ± i≈ülem
        String emoji = getLogEmoji(level);

        logger.info("{} [{}] {} - {} (Kaynak: {}, Zaman: {})",
                emoji, consumerName, level, message, source, timestamp);

        // Critical log'lar i√ßin √∂zel i≈ülem
        if ("ERROR".equals(level)) {
            logger.warn("üö® [{}] CRITICAL LOG detected: {}", consumerName, message);
        }
    }

    /**
     * Task i≈ülem s√ºresini hesapla
     */
    private int calculateProcessingTime(String task, Integer priority) {
        // Base time: task uzunluƒüuna g√∂re
        int baseTime = Math.min(task.length() * 10, 3000); // Max 3 saniye

        // Priority modifier: y√ºksek priority = hƒ±zlƒ± i≈ülem
        double priorityModifier = priority != null ? (11 - priority) / 10.0 : 1.0;

        return (int) (baseTime * priorityModifier);
    }

    /**
     * Priority'ye g√∂re task i≈ülem sim√ºlasyonu
     */
    private void simulateTaskProcessing(int priority) throws InterruptedException {
        // Y√ºksek priority = kƒ±sa bekleme
        int waitTime = (10 - priority) * 100; // 100ms - 900ms arasƒ±
        Thread.sleep(waitTime);
    }

    /**
     * Log level'a g√∂re emoji
     */
    private String getLogEmoji(String level) {
        switch (level.toUpperCase()) {
            case "ERROR":
                return "‚ùå";
            case "WARN":
                return "‚ö†Ô∏è";
            case "INFO":
                return "‚ÑπÔ∏è";
            case "DEBUG":
                return "üêõ";
            default:
                return "üìù";
        }
    }

    /**
     * Consumer'ƒ± durdur
     */
    public void stopConsumer() throws IOException {
        if (consumerTag != null && channel != null && channel.isOpen()) {
            channel.basicCancel(consumerTag);
            logger.info("üõë Consumer durduruldu");
        }
    }

    /**
     * Baƒülantƒ±yƒ± kapat
     */
    public void close() throws IOException, TimeoutException {
        if (channel != null && channel.isOpen()) {
            channel.close();
        }
        if (connection != null && connection.isOpen()) {
            connection.close();
        }
        logger.info("üîí RabbitMQ baƒülantƒ±sƒ± kapatƒ±ldƒ±");
    }

    /**
     * Graceful shutdown hook
     */
    private void setupShutdownHook() {
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                logger.info("üõë Graceful shutdown ba≈ülatƒ±lƒ±yor...");
                stopConsumer();
                close();
                logger.info("‚úÖ Graceful shutdown tamamlandƒ±");
            } catch (Exception e) {
                logger.error("‚ùå Shutdown hatasƒ±", e);
            }
        }));
    }

    /**
     * Consumer mode selection
     */
    public void runConsumer(String mode, String consumerName) throws IOException {
        setupShutdownHook();

        switch (mode.toLowerCase()) {
            case "simple":
                consumeSimpleMessages();
                break;
            case "work":
                consumeWorkQueue();
                break;
            case "logs":
                consumeLogMessages(consumerName != null ? consumerName : "default");
                break;
            case "priority":
                consumeWithPriority();
                break;
            default:
                logger.error("‚ùå Bilinmeyen mode: {}", mode);
                return;
        }

        // Consumer √ßalƒ±≈üƒ±r durumda tutulan loop
        try {
            while (true) {
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.info("‚ö†Ô∏è Consumer interrupted");
        }
    }

    /**
     * Main method
     */
    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("Usage: java SimpleConsumer <mode> [consumer-name]");
            System.out.println("Modes:");
            System.out.println("  simple   - Basit queue consumer");
            System.out.println("  work     - Work queue consumer (manual ack)");
            System.out.println("  logs     - Fanout exchange consumer");
            System.out.println("  priority - Priority queue consumer");
            return;
        }

        String mode = args[0];
        String consumerName = args.length > 1 ? args[1] : null;

        SimpleConsumer consumer = new SimpleConsumer();

        try {
            // Baƒülan
            consumer.connect();

            logger.info("üöÄ RabbitMQ Consumer ba≈ülatƒ±lƒ±yor - Mode: {}", mode);

            // Consumer'ƒ± √ßalƒ±≈ütƒ±r
            consumer.runConsumer(mode, consumerName);

        } catch (Exception e) {
            logger.error("‚ùå Consumer hatasƒ±", e);
        } finally {
            try {
                consumer.close();
            } catch (Exception e) {
                logger.error("‚ùå Baƒülantƒ± kapatma hatasƒ±", e);
            }
        }
    }
}