# RabbitMQ Exchange Patterns ve Routing

## üìã ƒ∞√ßindekiler

1. [Exchange Types Genel Bakƒ±≈ü](#exchange-types-genel-bakƒ±≈ü)
2. [Direct Exchange](#direct-exchange)
3. [Topic Exchange](#topic-exchange)
4. [Fanout Exchange](#fanout-exchange)
5. [Headers Exchange](#headers-exchange)
6. [Default Exchange](#default-exchange)
7. [Routing Patterns](#routing-patterns)
8. [Hands-on Lab](#hands-on-lab)

## üîÄ Exchange Types Genel Bakƒ±≈ü

RabbitMQ'da **Exchange**, mesajlarƒ± queue'lara y√∂nlendiren router g√∂revi g√∂r√ºr. Her exchange type'ƒ± farklƒ± routing algoritmasƒ± kullanƒ±r:

```mermaid
graph TD
    P[Producer] --> E1[Direct Exchange]
    P --> E2[Topic Exchange]
    P --> E3[Fanout Exchange]
    P --> E4[Headers Exchange]

    E1 --> Q1[Queue 1]
    E1 --> Q2[Queue 2]

    E2 --> Q3[Queue 3]
    E2 --> Q4[Queue 4]

    E3 --> Q5[Queue 5]
    E3 --> Q6[Queue 6]
    E3 --> Q7[Queue 7]

    E4 --> Q8[Queue 8]
    E4 --> Q9[Queue 9]
```

### Exchange Types Kar≈üƒ±la≈ütƒ±rmasƒ±

| Exchange Type | Routing Kriteri                | Kullanƒ±m Alanƒ±  | Performans |
| ------------- | ------------------------------ | --------------- | ---------- |
| **Direct**    | Exact routing key match        | Simple routing  | Y√ºksek     |
| **Topic**     | Pattern-based routing          | Complex routing | Orta       |
| **Fanout**    | Broadcast (ignore routing key) | Broadcasting    | En y√ºksek  |
| **Headers**   | Message headers                | Custom routing  | D√º≈ü√ºk      |

## üìç Direct Exchange

**Direct Exchange**, routing key'i **tam olarak** e≈üle≈üen queue'lara mesaj g√∂nderir.

### √áalƒ±≈üma Prensibi

```
Producer --[routing_key: "error"]--> Direct Exchange
                                           |
                    binding: "error" ------+---> Error Queue
                    binding: "warning" ----+---> Warning Queue
                    binding: "info" -------+---> Info Queue
```

### Python √ñrneƒüi - Log Sistemi

```python
# examples/rabbitmq/python/direct_exchange_producer.py
import pika
import json
import sys
from datetime import datetime

class LogProducer:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Direct exchange declare
        self.channel.exchange_declare(
            exchange='direct_logs',
            exchange_type='direct',
            durable=True
        )

    def send_log(self, severity, message):
        """Log mesajƒ± g√∂nder"""
        log_data = {
            'severity': severity,
            'message': message,
            'timestamp': datetime.now().isoformat(),
            'source': 'direct_producer'
        }

        # Direct exchange'e routing key ile g√∂nder
        self.channel.basic_publish(
            exchange='direct_logs',
            routing_key=severity,  # routing key = severity level
            body=json.dumps(log_data),
            properties=pika.BasicProperties(
                delivery_mode=2,  # Persistent
                content_type='application/json'
            )
        )

        print(f"üìù [{severity.upper()}] {message}")

    def close(self):
        self.connection.close()

# Kullanƒ±m
if __name__ == '__main__':
    producer = LogProducer()

    # Test log mesajlarƒ±
    producer.send_log('info', 'Application started successfully')
    producer.send_log('warning', 'High memory usage detected')
    producer.send_log('error', 'Database connection failed')
    producer.send_log('error', 'Critical system error')

    producer.close()
```

```python
# examples/rabbitmq/python/direct_exchange_consumer.py
import pika
import json
import sys

class LogConsumer:
    def __init__(self, severity_levels):
        self.severity_levels = severity_levels
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Exchange declare
        self.channel.exchange_declare(
            exchange='direct_logs',
            exchange_type='direct',
            durable=True
        )

        # Exclusive queue olu≈ütur
        result = self.channel.queue_declare(queue='', exclusive=True)
        self.queue_name = result.method.queue

        # Her severity i√ßin binding
        for severity in severity_levels:
            self.channel.queue_bind(
                exchange='direct_logs',
                queue=self.queue_name,
                routing_key=severity
            )

    def callback(self, ch, method, properties, body):
        """Log mesajƒ±nƒ± i≈üle"""
        try:
            log_data = json.loads(body)
            severity_emoji = {
                'info': 'üíô',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå',
                'critical': 'üî•'
            }.get(log_data['severity'], 'üìù')

            print(f"{severity_emoji} [{log_data['severity'].upper()}] "
                  f"{log_data['timestamp']}: {log_data['message']}")

        except Exception as e:
            print(f"‚ùå Parse error: {e}")

    def start_consuming(self):
        """Log dinlemeye ba≈üla"""
        self.channel.basic_consume(
            queue=self.queue_name,
            on_message_callback=self.callback,
            auto_ack=True
        )

        print(f"üëÇ Listening for {', '.join(self.severity_levels)} logs...")
        print("üî¥ Press CTRL+C to exit")

        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            self.channel.stop_consuming()
            self.connection.close()

# Kullanƒ±m: python direct_exchange_consumer.py error warning
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python direct_exchange_consumer.py [info] [warning] [error]")
        sys.exit(1)

    severity_levels = sys.argv[1:]
    consumer = LogConsumer(severity_levels)
    consumer.start_consuming()
```

## üîÑ Topic Exchange

**Topic Exchange**, routing key'leri **pattern'lere** g√∂re e≈üle≈ütirir. Wildcard karakterler kullanƒ±r:

- `*` (yƒ±ldƒ±z): Tek kelime
- `#` (diyez): Sƒ±fƒ±r veya daha fazla kelime

### Pattern √ñrnekleri

```
Routing Key Pattern: "stock.*.price"
‚úÖ Matches: stock.AAPL.price, stock.GOOGL.price
‚ùå No Match: stock.AAPL.volume, crypto.BTC.price

Routing Key Pattern: "news.#"
‚úÖ Matches: news.tech, news.tech.ai, news.finance.stock
‚ùå No Match: weather.today

Routing Key Pattern: "*.error"
‚úÖ Matches: app.error, db.error, cache.error
‚ùå No Match: app.warning, system.error.critical
```

### Python √ñrneƒüi - Haber Sistemi

```python
# examples/rabbitmq/python/topic_exchange_producer.py
import pika
import json
from datetime import datetime

class NewsProducer:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Topic exchange declare
        self.channel.exchange_declare(
            exchange='news_exchange',
            exchange_type='topic',
            durable=True
        )

    def publish_news(self, category, subcategory, urgency, title, content):
        """Haber yayƒ±nla"""
        # Routing key format: category.subcategory.urgency
        routing_key = f"{category}.{subcategory}.{urgency}"

        news_data = {
            'category': category,
            'subcategory': subcategory,
            'urgency': urgency,
            'title': title,
            'content': content,
            'timestamp': datetime.now().isoformat(),
            'routing_key': routing_key
        }

        self.channel.basic_publish(
            exchange='news_exchange',
            routing_key=routing_key,
            body=json.dumps(news_data),
            properties=pika.BasicProperties(
                delivery_mode=2,
                content_type='application/json'
            )
        )

        print(f"üì∞ Published: {routing_key} - {title}")

    def close(self):
        self.connection.close()

# Test haberleri
if __name__ == '__main__':
    producer = NewsProducer()

    # √áe≈üitli kategorilerde haberler
    producer.publish_news('tech', 'ai', 'high',
                         'New AI Breakthrough',
                         'Revolutionary AI model released...')

    producer.publish_news('tech', 'mobile', 'medium',
                         'New Smartphone Released',
                         'Latest smartphone features...')

    producer.publish_news('finance', 'crypto', 'high',
                         'Bitcoin Reaches New High',
                         'Bitcoin price surges to...')

    producer.publish_news('sports', 'football', 'low',
                         'Match Results',
                         'Yesterday match results...')

    producer.publish_news('weather', 'storm', 'critical',
                         'Storm Warning',
                         'Severe storm approaching...')

    producer.close()
```

```python
# examples/rabbitmq/python/topic_exchange_consumer.py
import pika
import json
import sys

class NewsConsumer:
    def __init__(self, routing_patterns):
        self.routing_patterns = routing_patterns
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Exchange declare
        self.channel.exchange_declare(
            exchange='news_exchange',
            exchange_type='topic',
            durable=True
        )

        # Exclusive queue
        result = self.channel.queue_declare(queue='', exclusive=True)
        self.queue_name = result.method.queue

        # Pattern'lere g√∂re binding
        for pattern in routing_patterns:
            self.channel.queue_bind(
                exchange='news_exchange',
                queue=self.queue_name,
                routing_key=pattern
            )
            print(f"üîó Bound to pattern: {pattern}")

    def callback(self, ch, method, properties, body):
        """Haber mesajƒ±nƒ± i≈üle"""
        try:
            news = json.loads(body)

            urgency_emoji = {
                'low': 'üü¢',
                'medium': 'üü°',
                'high': 'üü†',
                'critical': 'üî¥'
            }.get(news['urgency'], 'üì∞')

            print(f"\n{urgency_emoji} [{news['routing_key']}]")
            print(f"üì∞ {news['title']}")
            print(f"üí¨ {news['content']}")
            print(f"‚è∞ {news['timestamp']}")

        except Exception as e:
            print(f"‚ùå Parse error: {e}")

    def start_consuming(self):
        """Haber dinlemeye ba≈üla"""
        self.channel.basic_consume(
            queue=self.queue_name,
            on_message_callback=self.callback,
            auto_ack=True
        )

        print(f"üëÇ Listening for patterns: {', '.join(self.routing_patterns)}")
        print("üî¥ Press CTRL+C to exit\n")

        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            self.channel.stop_consuming()
            self.connection.close()

# √ñrnek kullanƒ±mlar:
# python topic_exchange_consumer.py "tech.*.*"        # T√ºm tech haberleri
# python topic_exchange_consumer.py "*.*.high"        # T√ºm y√ºksek √∂ncelikli
# python topic_exchange_consumer.py "tech.#" "finance.#"  # Tech ve finance t√ºm√º
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python topic_exchange_consumer.py <pattern1> [pattern2] [pattern3]...")
        print("Examples:")
        print("  tech.*.*          # All tech news")
        print("  *.*.high          # All high priority")
        print("  tech.# finance.#  # All tech and finance")
        sys.exit(1)

    patterns = sys.argv[1:]
    consumer = NewsConsumer(patterns)
    consumer.start_consuming()
```

## üì¢ Fanout Exchange

**Fanout Exchange**, routing key'i g√∂rmezden gelir ve mesajƒ± **t√ºm baƒülƒ± queue'lara** g√∂nderir.

### Kullanƒ±m Alanlarƒ±

- Broadcasting notifications
- Cache invalidation
- Real-time updates
- Event sourcing

### Python √ñrneƒüi - Bildirim Sistemi

```python
# examples/rabbitmq/python/fanout_exchange_producer.py
import pika
import json
from datetime import datetime

class NotificationProducer:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Fanout exchange declare
        self.channel.exchange_declare(
            exchange='notifications',
            exchange_type='fanout',
            durable=True
        )

    def broadcast_notification(self, notification_type, title, message, data=None):
        """Bildirim yayƒ±nla"""
        notification = {
            'type': notification_type,
            'title': title,
            'message': message,
            'timestamp': datetime.now().isoformat(),
            'data': data or {}
        }

        # Fanout exchange - routing key √∂nemli deƒüil
        self.channel.basic_publish(
            exchange='notifications',
            routing_key='',  # Fanout'ta routing key g√∂rmezden gelinir
            body=json.dumps(notification),
            properties=pika.BasicProperties(
                delivery_mode=2,
                content_type='application/json'
            )
        )

        print(f"üì¢ Broadcast: [{notification_type.upper()}] {title}")

    def close(self):
        self.connection.close()

# Test bildirimleri
if __name__ == '__main__':
    producer = NotificationProducer()

    # Sistem bildirimleri
    producer.broadcast_notification(
        'system',
        'Maintenance Warning',
        'System maintenance will start in 30 minutes',
        {'maintenance_duration': '2 hours', 'affected_services': ['api', 'web']}
    )

    producer.broadcast_notification(
        'security',
        'Security Alert',
        'Suspicious login attempt detected',
        {'ip': '192.168.1.100', 'location': 'Unknown'}
    )

    producer.broadcast_notification(
        'promotion',
        'Flash Sale Started',
        '50% discount on all items for next 2 hours!',
        {'discount': 50, 'duration': 120}
    )

    producer.close()
```

```python
# examples/rabbitmq/python/fanout_exchange_consumer.py
import pika
import json
import sys

class NotificationConsumer:
    def __init__(self, consumer_name, notification_types=None):
        self.consumer_name = consumer_name
        self.notification_types = notification_types or []

        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Exchange declare
        self.channel.exchange_declare(
            exchange='notifications',
            exchange_type='fanout',
            durable=True
        )

        # Exclusive queue (her consumer'ƒ±n kendi queue'su)
        result = self.channel.queue_declare(queue='', exclusive=True)
        self.queue_name = result.method.queue

        # Fanout exchange'e bind et
        self.channel.queue_bind(
            exchange='notifications',
            queue=self.queue_name
        )

    def callback(self, ch, method, properties, body):
        """Bildirim i≈üle"""
        try:
            notification = json.loads(body)

            # Type filtering (eƒüer belirtilmi≈üse)
            if (self.notification_types and
                notification['type'] not in self.notification_types):
                return

            type_emoji = {
                'system': '‚öôÔ∏è',
                'security': 'üîí',
                'promotion': 'üéâ',
                'alert': 'üö®',
                'info': '‚ÑπÔ∏è'
            }.get(notification['type'], 'üì¢')

            print(f"\n{type_emoji} [{self.consumer_name}] {notification['title']}")
            print(f"üí¨ {notification['message']}")
            print(f"‚è∞ {notification['timestamp']}")

            if notification.get('data'):
                print(f"üìã Data: {notification['data']}")

        except Exception as e:
            print(f"‚ùå Parse error: {e}")

    def start_consuming(self):
        """Bildirim dinlemeye ba≈üla"""
        self.channel.basic_consume(
            queue=self.queue_name,
            on_message_callback=self.callback,
            auto_ack=True
        )

        filter_msg = f" (filtering: {', '.join(self.notification_types)})" if self.notification_types else ""
        print(f"üëÇ [{self.consumer_name}] Listening for notifications{filter_msg}")
        print("üî¥ Press CTRL+C to exit\n")

        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            self.channel.stop_consuming()
            self.connection.close()

# Kullanƒ±m:
# python fanout_exchange_consumer.py mobile_app
# python fanout_exchange_consumer.py web_app system security
if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python fanout_exchange_consumer.py <consumer_name> [type1] [type2]...")
        print("Examples:")
        print("  mobile_app                    # All notifications")
        print("  web_app system security       # Only system and security")
        sys.exit(1)

    consumer_name = sys.argv[1]
    notification_types = sys.argv[2:] if len(sys.argv) > 2 else None

    consumer = NotificationConsumer(consumer_name, notification_types)
    consumer.start_consuming()
```

## üè∑Ô∏è Headers Exchange

**Headers Exchange**, mesaj header'larƒ±nƒ± kullanarak routing yapar. En esnek ama en yava≈ü exchange type'ƒ±dƒ±r.

### Binding Arguments

- `x-match: all` - T√ºm header'lar e≈üle≈ümeli
- `x-match: any` - Herhangi bir header e≈üle≈ümeli

### Python √ñrneƒüi - E-ticaret Sistemi

```python
# examples/rabbitmq/python/headers_exchange_producer.py
import pika
import json
from datetime import datetime

class OrderProducer:
    def __init__(self):
        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Headers exchange declare
        self.channel.exchange_declare(
            exchange='order_processing',
            exchange_type='headers',
            durable=True
        )

    def send_order(self, order_data, headers):
        """Sipari≈ü g√∂nder"""
        order = {
            'order_id': order_data['order_id'],
            'customer_id': order_data['customer_id'],
            'items': order_data['items'],
            'total_amount': order_data['total_amount'],
            'timestamp': datetime.now().isoformat()
        }

        # Headers exchange - routing key √∂nemli deƒüil
        self.channel.basic_publish(
            exchange='order_processing',
            routing_key='',  # Headers exchange'te kullanƒ±lmaz
            body=json.dumps(order),
            properties=pika.BasicProperties(
                delivery_mode=2,
                content_type='application/json',
                headers=headers  # Routing header'larƒ±
            )
        )

        print(f"üõí Order sent: {order_data['order_id']} - Headers: {headers}")

    def close(self):
        self.connection.close()

# Test sipari≈üleri
if __name__ == '__main__':
    producer = OrderProducer()

    # Farklƒ± header kombinasyonlarƒ± ile sipari≈üler

    # Premium m√º≈üteri, express kargo
    producer.send_order({
        'order_id': 'ORD-001',
        'customer_id': 'CUST-PREMIUM-123',
        'items': ['laptop', 'mouse'],
        'total_amount': 1500.00
    }, {
        'customer_type': 'premium',
        'shipping_type': 'express',
        'payment_method': 'credit_card',
        'amount_range': 'high'
    })

    # Standard m√º≈üteri, normal kargo
    producer.send_order({
        'order_id': 'ORD-002',
        'customer_id': 'CUST-STD-456',
        'items': ['book'],
        'total_amount': 25.99
    }, {
        'customer_type': 'standard',
        'shipping_type': 'standard',
        'payment_method': 'paypal',
        'amount_range': 'low'
    })

    # VIP m√º≈üteri, same-day delivery
    producer.send_order({
        'order_id': 'ORD-003',
        'customer_id': 'CUST-VIP-789',
        'items': ['phone', 'case', 'charger'],
        'total_amount': 899.99
    }, {
        'customer_type': 'vip',
        'shipping_type': 'same_day',
        'payment_method': 'credit_card',
        'amount_range': 'medium'
    })

    producer.close()
```

```python
# examples/rabbitmq/python/headers_exchange_consumer.py
import pika
import json
import sys

class OrderProcessor:
    def __init__(self, processor_name, header_match, match_headers):
        self.processor_name = processor_name
        self.header_match = header_match  # 'all' or 'any'
        self.match_headers = match_headers

        self.connection = pika.BlockingConnection(
            pika.ConnectionParameters(
                host='localhost',
                credentials=pika.PlainCredentials('admin', 'admin123')
            )
        )
        self.channel = self.connection.channel()

        # Exchange declare
        self.channel.exchange_declare(
            exchange='order_processing',
            exchange_type='headers',
            durable=True
        )

        # Exclusive queue
        result = self.channel.queue_declare(queue='', exclusive=True)
        self.queue_name = result.method.queue

        # Headers binding arguments
        binding_args = {'x-match': header_match}
        binding_args.update(match_headers)

        # Headers exchange'e bind et
        self.channel.queue_bind(
            exchange='order_processing',
            queue=self.queue_name,
            arguments=binding_args
        )

        print(f"üîó [{processor_name}] Bound with x-match: {header_match}")
        print(f"üìã Match headers: {match_headers}")

    def callback(self, ch, method, properties, body):
        """Sipari≈ü i≈üle"""
        try:
            order = json.loads(body)
            headers = properties.headers or {}

            print(f"\nüõí [{self.processor_name}] Processing Order: {order['order_id']}")
            print(f"üë§ Customer: {order['customer_id']}")
            print(f"üè∑Ô∏è Headers: {headers}")
            print(f"üí∞ Amount: ${order['total_amount']}")
            print(f"üì¶ Items: {', '.join(order['items'])}")

            # ƒ∞≈ülem simulasyonu
            self.process_order(order, headers)

        except Exception as e:
            print(f"‚ùå Processing error: {e}")

    def process_order(self, order, headers):
        """Sipari≈ü i≈üleme logic'i"""
        customer_type = headers.get('customer_type', 'unknown')
        shipping_type = headers.get('shipping_type', 'standard')

        if customer_type == 'vip':
            print("‚≠ê VIP customer - Priority processing")
        elif customer_type == 'premium':
            print("üíé Premium customer - Enhanced service")

        if shipping_type == 'express':
            print("‚ö° Express shipping - 1-2 days")
        elif shipping_type == 'same_day':
            print("üöÄ Same day delivery - Within 24 hours")
        else:
            print("üìÆ Standard shipping - 3-5 days")

    def start_consuming(self):
        """Sipari≈ü dinlemeye ba≈üla"""
        self.channel.basic_consume(
            queue=self.queue_name,
            on_message_callback=self.callback,
            auto_ack=True
        )

        print(f"üëÇ [{self.processor_name}] Listening for orders...")
        print("üî¥ Press CTRL+C to exit\n")

        try:
            self.channel.start_consuming()
        except KeyboardInterrupt:
            self.channel.stop_consuming()
            self.connection.close()

# Predefined processors
def create_premium_processor():
    """Premium m√º≈üteri sipari≈üleri"""
    return OrderProcessor(
        'Premium Processor',
        'any',  # Herhangi biri e≈üle≈üsin
        {'customer_type': 'premium', 'customer_type': 'vip'}
    )

def create_express_processor():
    """Express kargo sipari≈üleri"""
    return OrderProcessor(
        'Express Processor',
        'all',  # Hepsi e≈üle≈ümeli
        {'shipping_type': 'express', 'payment_method': 'credit_card'}
    )

def create_high_value_processor():
    """Y√ºksek tutarlƒ± sipari≈üler"""
    return OrderProcessor(
        'High Value Processor',
        'any',
        {'amount_range': 'high', 'amount_range': 'medium'}
    )

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python headers_exchange_consumer.py <processor_type>")
        print("Available processors:")
        print("  premium    # Premium/VIP customers")
        print("  express    # Express shipping orders")
        print("  high_value # High/Medium value orders")
        sys.exit(1)

    processor_type = sys.argv[1]

    if processor_type == 'premium':
        processor = create_premium_processor()
    elif processor_type == 'express':
        processor = create_express_processor()
    elif processor_type == 'high_value':
        processor = create_high_value_processor()
    else:
        print(f"‚ùå Unknown processor type: {processor_type}")
        sys.exit(1)

    processor.start_consuming()
```

## üîÑ Routing Patterns Best Practices

### 1. Direct Exchange Best Practices

- **Kullanƒ±m**: Basit, exact match routing
- **Naming**: Kƒ±sa, a√ßƒ±k routing key'ler (`error`, `warning`, `info`)
- **Performance**: En y√ºksek performans
- **√ñrnek**: Log levels, task priorities

### 2. Topic Exchange Best Practices

- **Naming Convention**: `category.subcategory.attribute`
- **Pattern Design**:
  - `#` sonuna: `stock.#` (t√ºm stock mesajlarƒ±)
  - `*` ortaya: `*.error` (t√ºm error'lar)
  - Specificity: `stock.AAPL.price` ‚Üí `stock.*.price` ‚Üí `stock.#`

### 3. Fanout Exchange Best Practices

- **Kullanƒ±m**: Broadcasting, caching, notifications
- **Queue Strategy**: Her consumer i√ßin ayrƒ± queue
- **Performance**: En hƒ±zlƒ± broadcast
- **Durability**: Notification'lar i√ßin genelde non-durable

### 4. Headers Exchange Best Practices

- **Kullanƒ±m**: Complex routing logic
- **Header Design**: Key-value pairs ile metadata
- **Match Strategy**:
  - `all`: Strict filtering
  - `any`: Flexible filtering
- **Performance**: En yava≈ü, complex logic i√ßin

## üß™ Hands-on Lab: Multi-Exchange Messaging System

Real-world scenario: **E-ticaret platformu** i√ßin messaging system tasarlayacaƒüƒ±z.

### Lab Senaryosu

**Sistem Gereksinimleri:**

1. **Order Processing** - Headers exchange ile complex routing
2. **Inventory Updates** - Topic exchange ile category-based routing
3. **System Notifications** - Fanout exchange ile broadcasting
4. **Error Logging** - Direct exchange ile severity-based routing

### Lab Kurulumu

```bash
# Lab scriptini √ßalƒ±≈ütƒ±r
chmod +x examples/rabbitmq/scripts/setup_multi_exchange_lab.sh
./examples/rabbitmq/scripts/setup_multi_exchange_lab.sh
```

### Test Senaryosu

```bash
# Terminal 1: Error logs dinle
python examples/rabbitmq/python/direct_exchange_consumer.py error warning

# Terminal 2: Tech haberleri dinle
python examples/rabbitmq/python/topic_exchange_consumer.py "tech.*.*"

# Terminal 3: Mobile app notifications dinle
python examples/rabbitmq/python/fanout_exchange_consumer.py mobile_app

# Terminal 4: Premium sipari≈üleri dinle
python examples/rabbitmq/python/headers_exchange_consumer.py premium

# Terminal 5: Test mesajlarƒ± g√∂nder
python examples/rabbitmq/python/direct_exchange_producer.py
python examples/rabbitmq/python/topic_exchange_producer.py
python examples/rabbitmq/python/fanout_exchange_producer.py
python examples/rabbitmq/python/headers_exchange_producer.py
```

## ‚úÖ √ñƒürendiklerimiz

Bu b√∂l√ºmde ≈üunlarƒ± √∂ƒürendik:

1. **Exchange Types**

   - Direct: Exact routing key match
   - Topic: Pattern-based routing
   - Fanout: Broadcasting
   - Headers: Metadata-based routing

2. **Routing Strategies**

   - Simple vs Complex routing
   - Performance considerations
   - Best practices

3. **Real-world Patterns**

   - Log aggregation (Direct)
   - News distribution (Topic)
   - Notifications (Fanout)
   - Order processing (Headers)

4. **Design Decisions**
   - Exchange type selection
   - Routing key design
   - Queue binding strategies

## üìö Sonraki Adƒ±m

Bir sonraki b√∂l√ºmde **RabbitMQ Advanced Features** konusunu i≈üleyeceƒüiz:

- Dead Letter Queues (DLQ)
- Message TTL (Time To Live)
- Queue and Message priorities
- Publisher Confirms
- Consumer Acknowledgments
- Clustering and High Availability

---

**üéØ Pratik G√∂rev:** Multi-exchange lab'ƒ± √ßalƒ±≈ütƒ±rƒ±n ve farklƒ± exchange pattern'lerini test edin. Management UI'da message flow'larƒ± g√∂zlemleyin.
